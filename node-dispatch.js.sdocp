sdocp('node-dispatch.js.sdoc', 'Dispatch server for node.js | Spencer Tipping\nLicensed under the terms of the MIT source code license\n\nMotivation.\nRunning multiple Node apps on a single server requires them to use different ports. This application routes HTTP requests to those different ports based on their URLs; for example, suppose you\nhave this routing table (called \'routes\' in this case):\n\n| foo on localhost:8081\n  bar on localhost:8082\n\nAny requests of the form "http://server/foo/..." will be routed as "http://server:8081/...", and requests to "http://server/bar/..." will go to "http://server:8082/...". You can update this\nrouting table at runtime and it will be reread without restarting the proxy server. (Thanks to http://catonmat.net for the watchFile tip!) You run the server as \'node node-dispatch.js routes\'\nin this case.\n\n  Reading the routes file.\n  This is fairly simple. The routing file supports line-comments starting with # in addition to rule definitions. Rule defs look like this:\n\n  | app on port n               # to route to a port on localhost\n    app on host:port            # to route to a port on any host\n\n  Nothing bad happens if you have a line that doesn\'t make sense; the server just prints a warning message.\n\n    var routing_table      = {},\n        read_routing_table = function (contents) {var lines = (contents || \'\').replace(/#.*(\\n|$)/g, \'$1\').split(/\\n\\s*/);\n                                                  routing_table = {};\n                                                  console.log(\'Reading routing table\');\n                                                  for (var i = 0, l = lines.length, parts; i < l; ++i)\n                                                    (parts = /^\\s*(\\w+) on port (\\d+)\\s*$/.exec(lines[i])) ?  (routing_table[parts[1]] = \'localhost:\' + parts[2]) :\n                                                    (parts = /^\\s*(\\w+) on (\\w+:\\d+)\\s*$/ .exec(lines[i])) ?  (routing_table[parts[1]] = parts[2]) :\n                                                                                    /^\\s*$/.test(lines[i]) || console.log(\'Bogus line in routing table: \' + lines[i])};\n    read_routing_table(require(\'fs\').readFileSync(process.argv[2], \'ascii\'));\n\n  Routing requests.\n  This requires a server that receives requests paired with a client that sends proxy requests. There is some minor URL rewriting, but nothing too bad. Each app definition in the routing table\n  is read as the root folder of the URL.\n\n    process.on(\'uncaughtException\', function (e) {console.log(e)});\n    require(\'http\').createServer(function (req, res) {\n      var parts = /\\/(\\w+)(\\/.*)/.exec(req.url);\n      parts ? routing_table[parts[1]] ?\n        (request = require(\'http\').createClient(Number(routing_table[parts[1]].split(/:/)[1]), routing_table[parts[1]].split(/:/)[0]).\n                                        request(req.method, parts[2], req.headers),\n         request.on(\'response\', function (response) {response.setEncoding(\'binary\');\n                                                     res.writeHead(response.statusCode, response.headers);\n                                                     response.on(\'data\', function (data) {res.write(data)});\n                                                     response.on(\'end\',  function     () {res.end()})}),\n         req.on(\'data\', function (data) {request.write(data, \'binary\')}),\n         req.on(\'end\',  function     () {request.end()})) : (res.writeHead(500), res.end(\'Application not found: \' + parts[1])) :\n                                                            (res.writeHead(500), res.end(\'Invalid URL: \' + req.url))}).listen(8080, \'0.0.0.0\');\n');